一、支持Arena的无锁的SkipList
    · 一般的skiplist通过一个锁来实现并发控制，但是通过Arena内存管理也可以实现并发控制；
      后面会实现一个支持CAS的无锁skiplist，同时引入了对Arena的支持，进一步提升skiplist的性能；

    · Arena暂时先理解为一个内存管理模块，主要的思想就是一次性向操作系统申请大块的内存空间，
      避免在跳表中插入数据时，频繁的向操作系统申请内存空间的性能开销；

    · Arena的核心发方法是allocate，后面包装了putNode、putKey、putVal等方法，
      也就是在Arena中插入一个skiplist节点、key值、value值；

    · 当引入了Arena以后，跳表中所有的数据将不是直接存储在跳表的数据结构中，在跳表中只会存储key值和value值的指针；
      如果需要读取Value的具体内容，需要用指针在Arena中读取到对应的Node值，因此Arena需要提供一个方法：
      传入一个指针值，返回一个skiplist的node；

二、Node
    · 由于node中不再直接存储具体的Value，所以需要重新定义一个节点Node结构体：
        type node struct {
            // 将value offset 和value size作为一个8字节编码在一起，便于实现CAS操作；
            value uint64
            // 尽量减少key的内存；
            keyOffset uint32 
            keySize   uint16 
            // 这个节点所处的层级，也就是说这个节点有几个next指针；
            height uint16
            // node的next指针数组，默认初始化最大高度maxHeight；
			// 实际上不一定会占用全部的内存空间
            tower [maxHeight]uint32
        }
	
	· 需要关注的关键点：
		1. Node中的value不是具体的值，而是可以描述在Arena当中的位置的变量；
		   描述再Arena中的位置，选哟得知再Arena当中的offset和lenght，这里将两个值按照固定长度编码再一起；
		   用一个uint64类型使用CAS机制来修改、读取value；

		2. Node中的key同样不是存储具体的值，但是没有将key合并编码这是因为key值本来就是不可被更新的，
		   也就不存在并发修改可能出现的问题，没有必要合并编码；

	· 因为重新规划了Node的成员变量，以及它们的表示和作用之后，需要重写几个基本的方法；

	
三、Node方法
	· 获取该节点的Value offset；
	  通过atomic.LoadUint64()和value的指针，再拆分前32位作为offset，后32位作为szie
	  因为go使用小端存储，也就是将低序的字节存储在起始地址上，直接使用 uint32(uint64) 就可以获得前32位(从右往左0~31)，再将value右移32位就是剩下的前32位；
		func (n *node) getValueOffset() (uint32, uint32) {
			value := atomic.LoadUint64(&n.value)
			return decodeValue(value)
		}
		func decodeValue(value uint64) (valOffset uint32, valSize uint32) {
			valOffset = uint32(value)
			valSize = uint32(value >> 32)
			return
		}

	· 获取节点的key，通过arena.getKey()和keyoffset和keysize实现；
	  详细来说就是使用offset定位到起始点，再使用offset+szie切片实现；
		func (n *node) key(arena *Arena) []byte {
			return arena.getKey(n.keyOffset, n.keySize)
		}
	
	· 原子的更新value
		func (n *node) setValue(arena *Arena, vo uint64) {
			atomic.StoreUint64(&n.value, vo)
		}
		
	· 获取该节点在h层的next指针
		func (n *node) getNextOffset(h int) uint32 {
			return atomic.LoadUint32(&n.tower[h])
		}
	
	· 原子更新节点的next指针
		func (n *node) casNextOffset(h int, old, val uint32) bool {
			return atomic.CompareAndSwapUint32(&n.tower[h], old, val)
		}
	
	· 有了这些基础的node方法就可以重写SkipList的逻辑了；

四、SkipList
	· 在跳表中获取下一个节点；
	  使用node.getNextOffset()拿到该node在指定level中的 在arena.buf中的偏移量，
	  再调用arena.getNode()获取到节点
		func (s *Skiplist) getNext(nd *node, height int) *node {
			return s.arena.getNode(nd.getNextOffset(height))
		}
	
	· 获取跳表的头节点；
	  通过skiplst.headOffset获取到头节点在arena.buf中的偏移量；
	  再调用arena.getNode()获取到节点
		func (s *Skiplist) getHead() *node {
			return s.arena.getNode(s.headOffset)
		}
		

	· 给定一个key，找到该值在每一层应该被插入的位置；
	  满足before key < key < next key；
	  返回before和next的offset；
		func (s *Skiplist) findSpliceForLevel(key []byte, before uint32, level int) (uint32, uint32) {
			for {
				// 假设before key < key
				beforeNode := s.arena.getNode(before)
				next := beforeNode.getNextOffset(level)
				nextNode := s.arena.getNode(next)
				// 如果before的next是空的，说明该level的单链表到头了
				if nextNode == nil {
					return before, next
				}
				nextKey := nextNode.key(s.arena)
				cmp := CompareKeys(key, nextKey)
				if cmp == 0 {
					// 找到了相同的key，说明需要更新key的值；
					// 返回回相同的节点，在外层统一处理
					return next, next
				}
				if cmp < 0 {
					// 满足before key < key < next key. 找到了在这层的合适的位置；
					return before, next
				}
				// else ；说明key > next key 说明还需要继续找
				before = next 
			}
		}
	
	· 给定一个key值，找到跳表中最接近该值的节点；
	  返回距离最近的节点(可能比key大，可能比key小，可能和key相等)；
	  如果less = true，会找到最右边的节点，且满足node key < key；
	  如果less = false，会找到最左边的节点，且满足node key > key；
		func (s *Skiplist) findNear(key []byte, less bool, allowEqual bool) (*node, bool) {
			// 找到头节点
			x := s.getHead()
			// 找到当前的链表层级
			level := int(s.getHeight() - 1)
			for {
				// Assume x.key < key.
				next := s.getNext(x, level)
				// 已经找到了链表尾部
				if next == nil {
					// 如果不是最后一层继续往下找
					if level > 0 {
						level--
						continue
					}
					// 如果是最后一层且找到了末尾；
					// 如果此时的less ==false，说明要找大于给定key的最小值；
					// 此时已经找到末尾，说明不存在比key大的值，只能放回nil,flase；
					if !less {
						return nil, false
					}
					// 判断此时是不是头节点
					// 如果是头节点，说明跳表中没有元素
					if x == s.getHead() {
						return nil, false
					}
					return x, false
				}
		
				nextKey := next.key(s.arena)
				cmp := CompareKeys(key, nextKey)
				if cmp > 0 {
					// x key < next < key，继续循环
					x = next
					continue
				}
				// x.key < key == next.key.
				if cmp == 0 {
					// 是否需要找相等的key
					if allowEqual {
						return next, true
					}
					if !less {
						// 需要找到大于key的，所以要再取一次next节点
						return s.getNext(next, 0), false
					}
					// 如果less == true，说明要继续找到小于key最近的值，且还没到最底层，所以继续循环；
					if level > 0 {
						level--
						continue
					}
					// 如果已经找到的skiplist的最底层，x还是头节点，说明skiplist是空的
					if x == s.getHead() {
						return nil, false
					}
					// 已经到了最底层且nextkey == key，说明x已经是最接近key的
					return x, false
				}
				// cmp < 0，说明x key < key < next；
				// 如果没到最后一层，继续查找
				if level > 0 {
					level--
					continue
				}
				// 如果已经到了最后一层，且要找比key大的，直接返回next
				if !less {
					return next, false
				}
				// 如果要找小于等于key的，判断skiplist是否为空
				if x == s.getHead() {
					return nil, false
				}
				// 返回当前x
				return x, false
			}
		}
	
	· 有了查找被插入位置的前后节点的方法，和查找离给定key最近的节点的方法，就可以实现put和get方法了；
	  Put方法的核心是，找到插入位置的前后节点，并将前后节点链接起来；
		// Entry是最外层对接用户的封装
		func (s *Skiplist) Add(e *Entry) {
			// 因为允许覆盖写入，所以不需要首先就创建新的node
			// 首先将用户传入的value数据转换为ValueStruct，也就是在跳表中存储的值，key直接使用entry.key
			key, v := e.Key, ValueStruct{
				Meta:      e.Meta,
				Value:     e.Value,
				ExpiresAt: e.ExpiresAt,
				Version:   e.Version,
			}
			// 获取当前跳表的高度，用于判断后续是否需要修改
			listHeight := s.getHeight()
			// 0 ~ listHeight层的前后节点
			var prev [maxHeight + 1]uint32
			var next [maxHeight + 1]uint32
			// 初始化prev数组，在当前skiplist的最高层的前缀节点初始为头节点
			prev[listHeight] = s.headOffset
			// 循环所有层
			for i := int(listHeight) - 1; i >= 0; i-- {
				// 通过findSpliceForLevel()找到每一层该插入位置的前后节点，
				// 每一层的起始节点都是上一层的前缀节点
				prev[i], next[i] = s.findSpliceForLevel(key, prev[i+1], i)
				// 如果前后节点相同，说明nextkey == key，说明需要覆盖找到的nextkey；
				// 将value放到arena.buf中，并获取到对应的offset；
				// 将offset编码为value，因为value是uint64，其中前32位(从右往左0~31)是offset，后32位是size
				// 拿到原来的这个位置的node，也就是prev[i]/next[i]，即 同一个key的node；
				// 直接复用node，将node的value编码改成新的编码
				if prev[i] == next[i] {
					vo := s.arena.putVal(v)
					encValue := encodeValue(vo, v.EncodedSize())
					prevNode := s.arena.getNode(prev[i])
					prevNode.setValue(s.arena, encValue)
					return
				}
			}
			// 如果需要执行到这一步，说明skiplist中没有相同的key，也就是说不需要覆盖写，需要插入一个新的node；
			
			// 首先获取随机高度，通过go:linkname来调用runtime.fastrand来实现快速获取随机数；
			// 再按照P==1/3的概率来获取node的高度；
			height := s.randomHeight()
			// 根据key、height、v在arena中分配空间，并初始化node的字段，返回node指针
			x := newNode(s.arena, key, v, height)
		
			// 判断是否需要更新skiplist的高度，并尝试原子CAS的更新
			listHeight = s.getHeight()
			for height > int(listHeight) {
				if atomic.CompareAndSwapInt32(&s.height, listHeight, int32(height)) {
					// 如果成功替换就跳出Try
					break
				}
				// 如果没有成功替换就继续尝试
				listHeight = s.getHeight()
			}
		
			// 从0层开始插入是为了简化并发插入冲突时的处理方法；
			// 因为发生冲突的A、B协程fastrand到的层级可能不一样，所以都从0开始
			for i := 0; i < height; i++ {
				for {
					// 因为newNode的height可能大于之前skiplist的高度，为了防止prev失效尝试重查
					if s.arena.getNode(prev[i]) == nil {
						AssertTrue(i > 1) 
						prev[i], next[i] = s.findSpliceForLevel(key, s.headOffset, i)
						AssertTrue(prev[i] != next[i])
					}
					// 将node.tower的每一层指向next[i]，因为x是一个newNode，所以不需要使用原子操作；
					// 但是pnode需要CAS原子操作
					x.tower[i] = next[i]
					pnode := s.arena.getNode(prev[i])
					if pnode.casNextOffset(i, next[i], s.arena.getNodeOffset(x)) {
						// 使用CAS将pnode的tower[i]从next[i]改为x对应的offset
						break
					}
					// 如果CAS失败了，说明pnode的对应的tower[i]已经不是next[i]，
					// 重新计算prev[i]和next[i]
					prev[i], next[i] = s.findSpliceForLevel(key, prev[i], i)
					// 说明当前skiplist被并发的插入了一个等key的node
					if prev[i] == next[i] {
						AssertTruef(i == 0, "Equality can happen only on base level: %d", i)
						// 因为所有的插入都是从0层开始，如果有两个协程A、B插入同一个key；
						// 要么B先插入到0层，A协程在第0层发现有相等的key，A协程将value更新为自己的，就直接退出了，剩下的链接tower的工作由B协程执行；
						vo := s.arena.putVal(v)
						encValue := encodeValue(vo, v.EncodedSize())
						prevNode := s.arena.getNode(prev[i])
						prevNode.setValue(s.arena, encValue)
						return
					}
				}
			}
		}
	
	· 然后是Get方法，Get方法的核心是查找整个skiplist，找到给定的key值；
		func (s *Skiplist) Search(key []byte) ValueStruct {
			// 通过findNear()找到一个大于等于key的node 
			n, _ := s.findNear(key, false, true) 
			// 如果n==nil，说明没有找到
			if n == nil {
				return ValueStruct{}
			}
			// 获取到node的key，因为nodeKey可能会大于要找的key，需要判断是否一样；
			nextKey := s.arena.getKey(n.keyOffset, n.keySize)
			if !SameKey(key, nextKey) {
				return ValueStruct{}
			}
			// 封装为ValueStruct
			valOffset, valSize := n.getValueOffset()
			vs := s.arena.getVal(valOffset, valSize)
			vs.ExpiresAt = ParseTs(nextKey)
			return vs
		}