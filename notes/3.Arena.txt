一、为什么需要内存管理
	· 在XHKV的应用场景中，处理的是大量的KV对的插入和删除；
	  在插入K-V时会触发申请内存的操作，操作系统需要借助系统调用，并且陷入到内核态，这需要带来额外的上下文切换的消耗；
	  尤其时在处理频繁的插入时，少量多次的内存申请需要大量的切换开销。这样对系统的性能带来很大的影响；
	  Go语言这个方面的解决方案是使用tcmalloc的思想在Go语言编译器层面进行内存分配；
	  理论上来说Golang已经帮助解决了内存分配的问题，那么为什么在设置KV存储引擎时还需要自己实现一个内存管理器呢？

	· Golang的内存分配是不区分业务逻辑的，也就是说，只要有程序申请内存，Golang都会满足，
	  也这就造成了memtable(SkipList)的内存可能和KV系统的代码的其他变量可能会共用到一块连续的内存；
	  这样的情况在memtable这种需要频繁申请内存的地方，如果混杂着其他的申请请求，很可能导致内存碎片的产生，从而影响分配的效率和空间的利用率；

	· 频繁申请、释放内存需要时间成本；
	  频繁申请、释放容易产生内存碎片；

二、内存碎片和解决方法
	· 假设变量A使用的是连续的内存空间4btyes，那么当变量A释放之后，另一个4byte的变量B就能完整放下，这样就不会造成内存碎片；
	  如果变量的A的4btye使用的是4块不连续的1btye，那么当变量A释放，即使内存空间有4byte的空闲，也会导致变量B无法放入，而是会使用一块新的足够大的内存；
	  而原来释放的4btyes空间，虽然没有被利用，但是仍占用进程的内存空间，这就导致内存碎片的产生；

	· 解决思路：
		· 内存分配中经常采用的一种方式就是使用预分配的一块比较大的内存，需要使用小块内存时，从这块大内存里面再分配；
		  再分配的过程可能只是移动指针或者更新变量，非常高效；
		
		· 但是这种方法可能会浪费一些内存；

	· 具体操作：
		· Arena只提供分配空间的操作，不提供释放空间的操作；
		  这是因为在KV存储系统的应用场景中，所有的操作都会被当做在Arena内存池中的追加操作，
		  当Arena在内存中占用的空间超过阈值之后，会将整个memtable转为immutable，随后会持久化为sst文件；
		  此时整个Arena内存空间可以被全部释放，所以Arena内存空间不需要自己完成对某些Key的操作，借助Golang的GC操作就能自动完成；


三、基本
	· 首先看看Arena的数据结构：
		type Arena struct {
			// n表示当前Arena已分配出去的内存大小，也就是Arena offset
			n          uint32
			shouldGrow bool
			// buf就是申请好的内存空间
			buf        []byte
		}
	
	· 初始化Arena：
		func newArena(n int64) *Arena {
			// 将数据从1开始存储，offset == 0始终保持为空
			out := &Arena{
				n:   1,
				buf: make([]byte, n),
			}
			return out
		}
	
	· 申请Arena中的空间：
		// 对s *Arena申请 sz unit32大小的空间，返回这块空间在Arena中的起始offset；
		func (s *Arena) allocate(sz uint32) uint32 {
			// 首先原子的在原有的偏移量上加上sz，支持并发申请空间
			offset := atomic.AddUint32(&s.n, sz)
			// 判断Arena是否允许扩大，如果不允许，判断一下添加后的offset是否越界
			if !s.shouldGrow {
				AssertTrue(int(offset) <= len(s.buf))
				return offset - sz
			}
		
			// 如果添加之后剩下的空间，不足以放下一个新的node，尝试扩容Arena；
			if int(offset) > len(s.buf)-MaxNodeSize {
				// 先得到当前Arena.buf的空间
				growBy := uint32(len(s.buf))
				// 如果空间已经大于了64mb，就扩大64mb
				if growBy > 1<<30 {
					growBy = 1 << 30
				}
				// 如果要扩的大小小于预计放入的大小 sz，就扩大sz
				if growBy < sz {
					growBy = sz
				}
				// 按照 翻倍 或者 扩大64mb 或者 扩大sz的方式来为Arena.buf开辟新的空间
				newBuf := make([]byte, len(s.buf)+int(growBy))
				// 将s.buf的内容copy到新开辟的newBuf中，然后判断是否copy成功；
				AssertTrue(len(s.buf) == copy(newBuf, s.buf))
				// 将Arena.buf该为新指向的newBuf；
				s.buf = newBuf
			}
			return offset - sz
		}

四、接口封装
	· 拥有了分配逻辑allocate()，就可以将allocate封装为skiplist中所需要的get、put操作；

	· putnode()，在Arena中开辟一个skiplistNode的空间；
	  只需要计算出所需要的Node大小，再将计算出来的size作为参数传入allocate()中；
	  返回Node的起始offset；
	  	func (s *Arena) putNodeDemo() uint32 {
			nodeSize = int(unsafe.Sizeof(node{}))
			n := s.allocate(nodeSize)
			return n
		}
	  Demo版本中实现了通过allocate在Arena内存池中开辟一块空间，将Node节点存入
	  再看一遍node的数据结构：
		type node struct {
            // 将value offset 和value size作为一个8字节编码在一起，便于实现CAS操作；
            value uint64
            // 尽量减少key的内存；
            keyOffset uint32 
            keySize   uint16 
            // 这个节点所处的层级，也就是说这个节点有几个next指针；
            height uint16
            // node的next指针数组，默认初始化最大高度maxHeight；
			// 实际上不一定会占用全部的内存空间
            tower [maxHeight]uint32
        }
	  可以发现SizeOf(node) == (8btyes + 4btyes + 2btyes + 2btyes + tower.size)，
	  在Demo中将maxHeight作为实际的层高保存了下来，在实际使用过程中，大多数的node.tower都小于maxHeight，也就是说浪费了大量的空间；
		func (s *Arena) putNodeDemo2(height int) uint32 {
			// maxHeight - height == 没有使用的层高高度
			// offsetSize == count 4
			// unusedSize计算出没有使用的空间
			unusedSize := (maxHeight - height) * offsetSize
		
			// const MaxNodeSize = int(unsafe.Sizeof(node{}))
			// 也就是说实际使用的空间为，16 + usedtower 
			l := uint32(MaxNodeSize - unusedSize)
			n := s.allocate(l)

			return n
		}
	  但是还有优化的空间；
	  对于内存的优化，一共有两个方向：内存分配和内存对齐；
		func (s *Arena) putNode(height int) uint32 {
			// maxHeight - height == 没有使用的层高高度
			// offsetSize == count 4
			// unusedSize计算出没有使用的空间
			unusedSize := (maxHeight - height) * offsetSize
		
			// const MaxNodeSize = int(unsafe.Sizeof(node{}))
			// const nodeAlign = int(unsafe.Sizeof(uint64(0))) - 1
			// 也就是说实际分配的空间为，16 + usedtower + 7 
			l := uint32(MaxNodeSize - unusedSize + nodeAlign)
			n := s.allocate(l)
			// 注意n是起始offset
			// 再做内存对齐
			m := (n + uint32(nodeAlign)) & ^uint32(nodeAlign)
			return m
		}
	  
	· getNode()是将分配给node的空间结构化；
		func (s *Arena) getNode(offset uint32) *node {
			if offset == 0 {
				return nil
			}
			// 将arena.buf从offset开始作为*node来读取，通过对*node.xxx赋值，可以映射到arena.buf进行修改
			return (*node)(unsafe.Pointer(&s.buf[offset]))
		}
	
	· putKey()：
	  同理上述的put过程，将一个数据放到Arena中，需要先在Arena.buf中分配一个足够大的空间；
		// 传入的参数是一个[]btye的原始key，返回的是原始key在buf中的offset；
		func (s *Arena) putKey(key []byte) uint32 {
			// 首先算出原始key的长度
			keySz := uint32(len(key))
			// 在buf中分配一个足够大的空间，得到key在buf中的offset
			offset := s.allocate(keySz)
			// 将key copy到buf中对应的段
			buf := s.buf[offset : offset+keySz]
			AssertTrue(len(key) == copy(buf, key))
			return offset
		}
	  
	· putVal()：
	  和上述的put操作略有不同的是，value中的值不仅仅包括实际的value值，可能还存在ttl、meta等概念；
	  当然可以选择将val每次都单独分配内存，并且记录offset和size；
	  但是为了减少分配空间的次数 和 node结构体中的变量数量，更好的方法是再用一个结构体来用固定的顺序封装它；
		type ValueStruct struct {
			Meta      byte
			Value     []byte
			ExpiresAt uint64
		
			Version uint64 // 
		}
	  还要将ValueStruct编码
		func (vs *ValueStruct) EncodedSize() uint32 {
			// 使用len(Value)就能得到value切片的szie，再加一就是加上了1byte的Meta；
			sz := len(vs.Value) + 1 
			// 
			enc := sizeVarint(vs.ExpiresAt)
			return uint32(sz + enc)
		}
	  ExpiresAt因为是uint64不是[]byte，所以计算要特殊处理：
		func sizeVarint(x uint64) (n int) {
			// 每右移7位看看是否为0，为0就break
			for {
				n++
				// 为什么是7不是8，后面会解释
				x >>= 7
				if x == 0 {
					break
				}
			}
			return n
		}
	  得到长度之后，将value值和ExpiresAt一起编码：
		func (vs *ValueStruct) EncodeValue(b []byte) uint32 {
			// 先将0位置放置位Meta
			b[0] = vs.Meta
			// 再对固定长度的ExpiresAt编码
			// 因为字节序的问题，采用小端编码，也就是说，每7位编一个码，如果后面还要连续就在头上置1，如果不连续就置为0；
			// 举个例子：0b110000011000000，按照7位分割开，1 1000001 1000000，编码后，会将小序的1000000放置在[]btye的起始点，
			// 因为数字没有终止，所以会将头置上1，也就是说会在[]btye的起始点放置11000000，同理在下一个放置11000001，最后一个没有连续，置为01；
			// 这就是为什么之前要移动7位来算长度
			// 返回的是编码锁占用的长度
			sz := binary.PutUvarint(b[1:], vs.ExpiresAt)
			// 再通过copy将[]byte类型value部分，复制到b[1+sz:]上
			n := copy(b[1+sz:], vs.Value)
			return uint32(1 + sz + n)
		}
	  总流程：
		// 传入一个ValueStruct
		func (s *Arena) putVal(v ValueStruct) uint32 {
			// 先计算需要分配的空间大小
			l := uint32(v.EncodedSize())
			// 分配空间
			offset := s.allocate(l)
			// 编码
			v.EncodeValue(s.buf[offset:])
			return offset
		}
	
	· getVal()：
	  通过putVal()知道了放入Value的核心就是对val的加码，那么getVal也就是对buf中的段进行解码操作
		func (s *Arena) getVal(offset uint32, size uint32) (ret ValueStruct) {
			ret.DecodeValue(s.buf[offset : offset+size])
			return
		}
	  解码：
		func (vs *ValueStruct) DecodeValue(buf []byte) {
			// 按照顺序，第一个就是Meta
			vs.Meta = buf[0]
			var sz int
			// 通过Uvarint将ExpiresAt解码，也就是将buf[1:]顺序取出，直到取出的某个数<=127(首位是0)
			// 再将所有取出来的数全都去掉首位，再拼接起来
			vs.ExpiresAt, sz = binary.Uvarint(buf[1:])
			// 最后剩下的就是[]byte的value
			vs.Value = buf[1+sz:]
		}


五、用户操作
	· 经过get、put的操作，两个KV对在Arena的视图就是：
		Element1 ：				Element2：
			Keyoffset：0			Keyoffset：15
			KeySzie：8				KeySzie：6
			Valoffset：9			Valoffset：22
			ValSize：6				ValSize：6
	  可以发现，要对Element的Val做更新的操作时，要将Element锁住，因为要更新Valoffset和ValSize两个变量；
	  因为不希望向LevelDb一样不支持原地的操作，所以大量的更新操作会导致大量的锁冲突；
	  但是对两个变量实现无所的并发操作很难做到，那么就可以考虑将讲个变量合并为一个变量；

	· 因为Valoffset和ValSize都是uint32类型的数据，那么可以将两个合并为uint64来存储：
		func encodeValue(valOffset uint32, valSize uint32) uint64 {
			// 将valSize左移32位，这时候右边32位都是0；
			// 再|上左边全是0的valOffset，就得到了uint64表示的val所有信息
			return uint64(valSize)<<32 | uint64(valOffset)
		}
		// 解码只需要反向加码的操作即可
		func decodeValue(value uint64) (valOffset uint32, valSize uint32) {
			// 先将后面的32位提取出来作为offset
			valOffset = uint32(value)
			// 再将value右移32位，就是valSize
			valSize = uint32(value >> 32)
			return
		}

	· 这时候内存模块就基本上已经全部完成了，也就构成了skiplist的模样；
		type Skiplist struct {
			height     int32 // Current height. 1 <= height <= kMaxHeight. CAS.
			headOffset uint32
			ref        int32
			arena      *Arena
			OnClose    func()
		}
	  每个skiplist都会持有一个Arena，然后下面是初始化newNode的完成过程
		func newNode(arena *Arena, key []byte, v ValueStruct, height int) *node {
			nodeOffset := arena.putNode(height)
			keyOffset := arena.putKey(key)
			val := encodeValue(arena.putVal(v), v.EncodedSize())
		
			node := arena.getNode(nodeOffset)
			node.keyOffset = keyOffset
			node.keySize = uint16(len(key))
			node.height = uint16(height)
			node.value = val
			return node
		}
		