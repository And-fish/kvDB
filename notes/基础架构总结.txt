一、基本组件
    · 组件交互
        · 采用的是经典的LSM Tree架构，但是与传统的LSMTree不同的地方在于，引入了Wisckey KV分离特性；
          也就是当value比较大的时候，会使用KV分离的方式进行存储，这样减少了写放大 (compact的时候不会重写大value)；

        · 内存部分：
            · 在内存部分称为MemTable，分为MemTabel 和 Immutable Memtable，具体的实现采用的是Skiplist，
              对外提供了一些结构，来实现一个完整的KV读写流程

        · 磁盘部分：
            · 磁盘部分分为三个部分：
                · LevelManager：所有的SSTable都是通过LevaelManager进行管理的；
                · WAL文件：将数据写入到Memtable之前，需要先写入到WAL文件保证了一致性；
                · VLog：KV分离后，Value存储的文件


二、接口设计
    · 需要提供的API有：Open(打开并初始化一个DB)、关闭DB并清理占用空间、在DB中进行增删改查/遍历操作；
    
    · Open：
        Open需要可以显式的打开数据库，Open(opt *Options)*DB；
        这个方法需要传入一些配置参数，返回值是一个DB实例，其他的API都通过这个DB对象调用；
        Options中需要提供几个必须的配置参数：
            1. 因为实现了KV分离，当Value需要达到多大的阈值需要进行KV分离需要根据业务情况定制，依次需要对外提供可配置的选项；
            2. 同理MemTable、SSTable、Vlog的Size都需要提供可配置选项；

            type Options struct {
                ValueThreshold      int64
                WorkDir             string
                MemTableSize        int64
                SSTableMaxSz        int64
                MaxBatchCount       int64
                MaxBatchSize        int64 // max batch size in bytes
                ValueLogFileSize    int
                VerifyValueChecksum bool
                ValueLogMaxEntries  uint32
                LogRotatesToFlush   int32
                MaxTableSize        int64
            }
    
    · Close()：
        关闭数据库，清理资源占用，包括打开的文件描述符、占用的内存资源；
        包括 MemTable的内存占用、Vlog的文件描述符、Stat统计信息的内存占用；

    · API：
        · Set：新增一个KV对
        · Get：获取一个KV对
        · Del：删除一个KV对
        · Update：更新一个KV对
        · Range：遍历所有的KV对

    · Info：
        返回统计信息
        type DB struct {
            sync.RWMutex
            opt   *Options
            lsm   *lsmt.LSM
            vlog  *valueLog
            stats *Stats
        
            flushCh     chan flushTask
            writeCh     chan *request
            blockWrites int32
            vptrHead    *utils.ValuePtr
            logRotates  int32
        }


三、实现原理
    · 首先整理一下所有组件的接口情况：
        1. LSM Tree包含两个部分MemTable、SSTable，调用LSM的Set接口可以将数据写入；调用Get接口可以将数据读出；
           同时，LSM提供了NewLSM初始化方法，和Close清理资源的方法；

        2. Vlog提供了Open、Close、write、read方法，唯一需要感知到的接口就是newValuePtr，
           这方法将单个的Value包装为Vlog可以识别的Request，将Request写入到Vlog中并且返回Vlog的指针；

        3. 这些组件提供所有的对外接口，MemTable和SSTable共同组成LSM Tree，通过LSM Tree对外提供的接口可以实现set、get；
           调用LSM的Set方法，为了保证一致性读，会集成WAL文件的write的方法到LSM的Set中；

    · Set接口：
        1. 调用者要将存储的Key和Value组装为一个Entry对象；
        2. 调用者调用Set方法传入Entry结构体到db中；
        3. 判断是否需要KV分离，如果需要，会重构Value，调用NewValuePtr创建新的valuePtr并写入到Vlog中；
        4. 调用LSM.Set写入到Lsm中；
        5. Value此时可能是ValuePtr也有可能是真实的Value，会通过一个Meta标识位去判断；

    · Get接口：
        1. 调用者调用Get方法，传入需要查找的[]byte类型的Key值；
        2. 直接调用LSM的Get方法，从LSM中查找，如果找不到返回NotFound；
        3. 如果查找到了，需要判断是不是ValuePtr，如果是需要进行解码；
        4. 如果不是ValuePtr类型，直接组转位Entry；如果是，需要通过解码传入到Vlog中拿到Vlog中存储的值；
        5. 判断Entry是否是已经过期的key；
        6. 返回Entry或者ErrKeyNotFound

    · 更新和删除操作：
        这两种擦欧总都可以被视为特殊的Set操作；
        因为LSMTree支持MemTable中的原地更新操作，Set会出现三种情况：
            1. 如果原始值还在MemTable中，Set相同的key可以保证MemTable会存在最新的Key，当Get时会最先读取Memtable，就能保证读到最新的value；
            2. 如果原始值被刷到SST文件中，新的Set值还在Memtable中，那么MemTable中会存在最新的Key，此时最先读取MemTable，也能保证读取到最新的值；
            3. 如果原始值和新值都被刷到了不同的SSTable中，，由于LSMTree的读取策略，能够保证读到最新的SSTabel中的最新key；

        对于删除操作，可以利用墓碑机制，也就是将Value设置为nil值，这样在读取的时候会返回NotFound；

    
    · TTL：
        可以使用TTL功能进行过期处理操作，有两种情况可以触发：
            1. 在触发读写操作时进行检查，在SSTable文件进行Compaction时，会对所有的KV对进行有效期的检查，
               过期数据在Compaction的时候会被丢弃，减少没有必要的写入操作；在Get方法取到到数据后，返回前，会再次进行有效期的检查；
            2. 静默时的数据检查
    
    · Range：
        Range接口的实现功能时遍历整个DB，这需要调用各个模块的Iterator来组合实现这个功能;
        Range接口的输出结果是当前DB中存储的所有有效的KV对，同时这些KV对应该按照一定的顺序有序输出(取决于实现过程中使用的比较器)，这里按照的是字典序从小到大；
        需要考虑的问题就是如果正确使用各个组件的iterator对所有的Key-Value遍历一遍；

        在DB中每个组件都拥有自己的Iterator：
            1. MemTable的MemTable，作用是遍历整个MemTable；
            2. SST文件ContactIterator作用是遍历所有的SSTable，每个Table文件都具有自己的Iterator实现，通过ContactItertor进行组合迭代；
               其中Level 0层的SST文件因为Key值范围重合，不能使用ContactIterator进行组合，只能单独对每个Table的Iterator进行遍历；
            3. 因此只需要把所有的Iterator全部遍历一遍，所有的KV对就会输出；并且不需要担心遍历到被删除/失效的KV(还没有被Compact)；
               DBiterator是DB最外层的迭代器实现，最终的实现是依赖MergeIterator，MergeIterator当中持有所有的Iterator，采用多路归并的思想进行遍历；
               在遍历MergeIterator时会比较所有Iterator的Key值大小，把当前的所有Iterator中最小的Key输出；
